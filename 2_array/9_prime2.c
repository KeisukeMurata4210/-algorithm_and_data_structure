/* 1,000以下の素数を列挙（第2版） */
# include <stdio.h>

int main(void)
{
  int i, n;
  int prime[500];            /* 素数を格納する */
  int ptr = 0;               /* すでに得られた素数の個数 */
  unsigned long counter = 0; /* 除算の回数 */  /* 非負だからunsigned、計算回数が多いからlong */

  prime[ptr++] = 2;    /* 2は素数。　ptr++の使い方が見事だ */
  for (n = 3; n <= 1000; n += 2) { /* すごい！　素数は奇数のみに着目して半分にした。そして「n += 2」をここで使う */
    for (i = 1; i < ptr; i++) {
      counter++;
      if (n % prime[i] == 0)  /* 素数で割り切れたら素数ではない */
        break;
    }
    if (ptr == i)  /* 内側forを全てループできた＝割り切れなかった、ということ */
      prime[ptr++] = n;/* 素数だと認定されるので配列に加える */
  }
  for (i = 0; i < ptr; i++)
    printf("%d\n", prime[i]);
  printf("除算を行なった回数：%lu\n", counter);
  return 0;
}

/*
・「トランフェイズ装甲」みたいな省エネの考え方好き
・prime[ptr++]を使いこなせたら色々な場面でコードを短くできるんじゃないか
*/

/*
・同じ解を得るためのアルゴリズムは一つであるとは限らない
・高速なアルゴリズムは、より多くの記憶域を必要とする傾向がある
*/